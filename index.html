<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ZETA: Descent into Void</title>
  <meta name="viewport" content="width=320,initial-scale=1,user-scalable=no">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    html, body {margin:0;height:100%;overflow:hidden;background:#1a001a;}
    body {width:100vw;height:100vh;}
    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: #1a001a;
      image-rendering: pixelated;
      touch-action: none;
    }
    .dialog {
      font-family: 'Press Start 2P', monospace;
      background: rgba(20,0,30,0.96);
      color: #fff;
      border: 2px solid #5c1a5c;
      position: absolute;
      left: 50%; bottom: 24px; transform: translateX(-50%);
      min-width: 220px; max-width: 90vw;
      padding: 12px 16px;
      z-index: 10;
      font-size: 14px;
      border-radius: 8px;
      box-shadow: 0 0 12px #000a;
      display: none;
      user-select: none;
      pointer-events: auto;
    }
    .controls {
      display: none; position: absolute; bottom: 18px; left: 50%; transform:translateX(-50%);
      z-index: 20; gap: 12px; width: 100vw; justify-content: center;
    }
    .controls button {
      width: 54px; height: 54px;
      background: #330033cc;
      border: 2px solid #5c1a5c;
      border-radius: 10px;
      color: #fff; font-size: 32px; font-family: inherit;
      margin: 0 4px; user-select: none; outline: none;
      box-shadow: 0 2px 12px 0 #0006;
      pointer-events: auto;
      touch-action: none;
      transition: filter 0.12s, background 0.12s;
    }
    .controls button.pressed { background: #6622aa; filter: brightness(1.25); }
    @media (max-width: 700px) {
      .controls { display: flex; }
      .dialog { font-size: 18px; min-width: 50vw;}
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="320" height="180"></canvas>
  <div class="dialog" id="dialog"></div>
  <div class="controls" id="controls">
    <button id="btn-left">&#8592;</button>
    <button id="btn-right">&#8594;</button>
    <button id="btn-jump">&#8593;</button>
    <button id="btn-attack">&#9935;</button>
    <button id="btn-interact">E</button>
  </div>
  <script>
  // ==== ZETA: Descent into Void - Procedural Level + Working Enemies ====

  // --- Config ---
  const CANVAS_BASE_W = 320, CANVAS_BASE_H = 180;
  const TILE = 16;
  const PLAYER_SIZE = 16;
  const PLAYER_SPEED = 1.7;
  const PLAYER_JUMP = 3.8;
  const GRAVITY = 0.18;
  const ENEMY_SPEED = 0.7;
  const ENEMY_DAMAGE = 1;
  const font = "'Press Start 2P', monospace";
  const MAX_HP = 6;
  let dialogActive = false;
  let attackTimer = 0;
  let gameOver = false;

  // --- Canvas / Context ---
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let scale = 1;

  // --- Reliable Mobile Controls State ---
  const controlsState = { left:false, right:false, jump:false, attack:false, interact:false };
  function bindMobileControls() {
    const map = [
      ["btn-left", "left"],
      ["btn-right", "right"],
      ["btn-jump", "jump"],
      ["btn-attack", "attack"],
      ["btn-interact", "interact"]
    ];
    map.forEach(([btnId, flag]) => {
      const el = document.getElementById(btnId);
      el.addEventListener("touchstart", e => {
        e.preventDefault();
        controlsState[flag] = true;
        el.classList.add("pressed");
      }, {passive:false});
      el.addEventListener("touchend", e => {
        e.preventDefault();
        controlsState[flag] = false;
        el.classList.remove("pressed");
      }, {passive:false});
      el.addEventListener("touchcancel", e => {
        controlsState[flag] = false;
        el.classList.remove("pressed");
      });
    });
  }
  bindMobileControls();

  // --- Responsive Canvas ---
  function resizeCanvas() {
    const w = window.innerWidth, h = window.innerHeight;
    scale = Math.floor(Math.min(w/CANVAS_BASE_W, h/CANVAS_BASE_H));
    canvas.style.width = (CANVAS_BASE_W*scale)+"px";
    canvas.style.height = (CANVAS_BASE_H*scale)+"px";
    canvas.style.position = "absolute";
    canvas.style.left = "50%";
    canvas.style.top = "50%";
    canvas.style.transform = `translate(-50%, -50%) scale(1)`;
    document.body.style.overflow = "hidden";
  }
  window.addEventListener("resize", resizeCanvas); resizeCanvas();

  // --- Show/hide controls for mobile ---
  function showControlsIfMobile() {
    let isMobile = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent) || window.innerWidth < 700;
    document.getElementById("controls").style.display = isMobile ? "flex" : "none";
  }
  showControlsIfMobile();
  window.addEventListener("resize", showControlsIfMobile);

  // --- Procedural Level Generation ---
  function generateRoom(width=20, height=9) {
    let map = Array(height).fill().map(()=>Array(width).fill(' '));
    for(let x=0; x<width; x++) { map[0][x]='='; map[height-1][x]='='; }
    for(let y=0; y<height; y++) { map[y][0]='='; map[y][width-1]='='; }
    // Place floor
    for(let x=1; x<width-1; x++) map[height-2][x]='=';
    // Add random platforms
    for(let i=0; i<4; i++) {
      let px = 2+Math.floor(Math.random()*(width-6));
      let py = 2+Math.floor(Math.random()*(height-4));
      for(let j=0; j<3+Math.floor(Math.random()*2); j++)
        if(px+j<width-1) map[py][px+j]='=';
    }
    // Place door (always on right side)
    let doorX = width-2, doorY = height-3;
    map[doorY][doorX] = '+';
    // Place a few enemies on platforms or floor
    let enemyList = [];
    let placed = 0;
    while(placed < 3) {
      let ex = 2+Math.floor(Math.random()*(width-4));
      let ey = 1+Math.floor(Math.random()*(height-4));
      if (map[ey][ex] === ' ' && (map[ey+1][ex] === '=')) {
        map[ey][ex]='*';
        enemyList.push({x:ex*TILE, y:ey*TILE, vx:ENEMY_SPEED*(Math.random()<0.5?-1:1), vy:0, dir:Math.random()<0.5?-1:1, dead:false});
        placed++;
      }
    }
    // Place NPC or lore
    map[2][2]='n'; map[2][width-3]='@';
    return {map: map.map(row=>row.join('')), enemies: enemyList, door: {x:doorX, y:doorY}};
  }

  // --- Rooms ---
  let autogenRoom = generateRoom();
  let rooms = {
    autogen: {
      name: "Procedural Room",
      map: autogenRoom.map,
      doors: [ { x: autogenRoom.door.x, y: autogenRoom.door.y, target: "autogen", tx: 1, ty: autogenRoom.door.y } ],
      bg: "#181035"
    }
  };

  // --- Game State ---
  let gameState = {
    room: "autogen",
    player: {x: 32, y: 64, vx: 0, vy: 0, hp: MAX_HP, onGround: false, facing: 1, attacking: false, jumpCount: 0, invuln:0},
    dialog: null,
    enemies: JSON.parse(JSON.stringify(autogenRoom.enemies)),
    notes: [],
    corruption: 0
  };

  // --- Drawing ---
  function drawTile(ch, x, y) {
    if (ch === '=' || ch === '|') {
      ctx.fillStyle = ch === '=' ? "#4b236c" : "#33103c";
      ctx.fillRect(x, y, TILE, TILE);
    } else if (ch === '+') {
      ctx.strokeStyle = "#a0a";
      ctx.lineWidth = 3;
      ctx.strokeRect(x+2, y+2, TILE-4, TILE-4);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 1;
    } else if (ch === '*') {
      ctx.fillStyle = "#a01034";
      ctx.fillRect(x+2, y+4, 12, 10);
      ctx.fillStyle = "#f33";
      ctx.fillRect(x+5, y+7, 2, 2);
      ctx.fillRect(x+9, y+7, 2, 2);
    } else if (ch === 'n') {
      ctx.fillStyle = "#4060c0";
      ctx.fillRect(x+2, y+2, 12, 13);
      ctx.fillStyle = "#fff";
      ctx.fillRect(x+6, y+5, 4, 4);
      ctx.fillStyle = "#0ef";
      ctx.fillRect(x+7, y+7, 2, 2);
    } else if (ch === '@') {
      ctx.fillStyle = "#333";
      ctx.fillRect(x+3, y+6, 10, 6);
      ctx.fillStyle = "#0f0";
      ctx.fillRect(x+6, y+7, 4, 2);
    }
  }

  function drawPlayer(x, y, facing, attacking, attackFrame) {
    ctx.save();
    ctx.translate(x+PLAYER_SIZE/2, y+PLAYER_SIZE/2);
    ctx.scale(facing,1);
    ctx.fillStyle = "#c0a0ff";
    ctx.fillRect(-8, -8, 16, 16);
    ctx.fillStyle = "#fff";
    ctx.fillRect(-4, -4, 8, 8);
    ctx.restore();
    if (Math.random()<0.5) {
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#c0a0ff";
      ctx.beginPath();
      ctx.arc(x+8+Math.random()*4-2, y+16, 2+Math.random()*2, 0, 6.29);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    if (attacking && attackFrame>0) {
      ctx.save();
      ctx.globalAlpha = 0.75;
      ctx.strokeStyle = "#b7a3ff";
      ctx.lineWidth = 2.3;
      let fx = facing>0 ? x+18 : x-2;
      let fy = y+8;
      ctx.beginPath();
      ctx.moveTo(fx, fy-6); ctx.lineTo(fx, fy+6);
      ctx.moveTo(fx-6, fy); ctx.lineTo(fx+6, fy);
      ctx.moveTo(fx-5, fy-5); ctx.lineTo(fx+5, fy+5);
      ctx.moveTo(fx-5, fy+5); ctx.lineTo(fx+5, fy-5);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawHearts(hp) {
    for (let i=0; i<Math.ceil(hp/2); i++) {
      ctx.fillStyle = "#f33";
      ctx.beginPath();
      ctx.moveTo(20+i*18, 17); ctx.bezierCurveTo(20+i*18,11,12+i*18,11,12+i*18,17);
      ctx.bezierCurveTo(12+i*18,23,20+i*18,27,20+i*18,27);
      ctx.bezierCurveTo(20+i*18,27,28+i*18,23,28+i*18,17);
      ctx.bezierCurveTo(28+i*18,11,20+i*18,11,20+i*18,17);
      ctx.fill();
    }
  }

  // --- Dialog System ---
  const dialogDiv = document.getElementById("dialog");
  function showDialog(text, choices) {
    dialogActive = true;
    dialogDiv.style.display = "block";
    if (typeof text === "string") text = [text];
    let idx = 0, ci = 0, lines = text, fullText = '';
    function typeLine() {
      if (idx >= lines.length) {
        if (choices) {
          dialogDiv.innerHTML += "<br><br>";
          choices.forEach((c, i) => dialogDiv.innerHTML += `<span style="color:#c0f">${i+1}. ${c[0]}</span><br>`);
          dialogDiv.onclick = null;
        } else {
          dialogDiv.onclick = hideDialog;
        }
        return;
      }
      let line = lines[idx], out = '';
      function tick() {
        if (ci < line.length) {
          out += line[ci];
          dialogDiv.innerHTML = fullText + out + "<span style='opacity:0.3'>_</span>";
          ci++;
          setTimeout(tick, 22);
        } else {
          fullText += out+"<br>"; idx++; ci=0;
          setTimeout(typeLine, 160);
        }
      }
      tick();
    }
    dialogDiv.onclick = hideDialog;
    typeLine();
  }
  function hideDialog() {
    dialogActive = false;
    dialogDiv.style.display = "none";
    dialogDiv.onclick = null;
  }
  dialogDiv.addEventListener("click", e => {
    if (!dialogActive) return;
    if (gameState.dialog && gameState.dialog.choices) {
      let y = e.offsetY, idx = Math.floor((y-60)/28);
      if (gameState.dialog.choices[idx]) {
        gameState.dialog.choices[idx][1]();
        hideDialog();
      }
    }
  });

  // --- Input ---
  let keys = {};
  window.addEventListener("keydown", e => {
    keys[e.key.toLowerCase()]=true;
    if (e.key === " " && !dialogActive) startAttack();
  });
  window.addEventListener("keyup", e => keys[e.key.toLowerCase()]=false);

  function startAttack() {
    let p = gameState.player;
    if (!p.attacking) {
      p.attacking = true;
      attackTimer = 12;
    }
  }

  // --- Main Game Loop ---
  function gameLoop() {
    let p = gameState.player;
    if(gameOver) {
      ctx.fillStyle="#000b";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.font = "bold 28px "+font;
      ctx.fillStyle="#f44";
      ctx.textAlign="center";
      ctx.fillText("GAME OVER", CANVAS_BASE_W/2, CANVAS_BASE_H/2);
      ctx.font = "bold 16px "+font;
      ctx.fillStyle="#fff";
      ctx.fillText("Tap R to restart", CANVAS_BASE_W/2, CANVAS_BASE_H/2+32);
      requestAnimationFrame(gameLoop);
      return;
    }

    let left = keys['arrowleft']||keys['a']||controlsState.left;
    let right = keys['arrowright']||keys['d']||controlsState.right;
    let jump = keys['arrowup']||keys['w']||controlsState.jump;

    // DOUBLE JUMP LOGIC
    if (!dialogActive) {
      if (left) { p.vx = -PLAYER_SPEED; p.facing = -1; }
      else if (right) { p.vx = PLAYER_SPEED; p.facing = 1; }
      else p.vx = 0;

      // If pressing jump and jumpCount < 2, jump and increment jumpCount
      if (jump && p.jumpCount < 2) {
        p.vy = -PLAYER_JUMP;
        p.onGround = false;
        p.jumpCount++;
        controlsState.jump = false; // Prevent holding jump
      }
      if (controlsState.attack) { startAttack(); controlsState.attack = false; }
      if (controlsState.interact) { /* interact logic here if needed */ controlsState.interact = false; }
    } else {
      p.vx = 0;
    }

    p.vy += GRAVITY;
    let nextX = p.x + p.vx, nextY = p.y + p.vy;
    let col = collideWithMap(nextX, p.y);
    if (!col.x) p.x = nextX; else p.vx = 0;
    col = collideWithMap(p.x, nextY);
    if (!col.y) {
      p.y = nextY; 
      if (p.onGround) { p.onGround = false; }
    } else {
      p.vy = 0; 
      if (!p.onGround) {
        p.onGround = true;
        p.jumpCount = 0; // Reset double jump when touching ground
      }
    }

    // --- Enemy logic ---
    for(let e of gameState.enemies) {
      if(e.dead) continue;
      // Patrol: Turn if edge or wall
      let ex = e.x/TILE, ey = e.y/TILE;
      let nx = Math.floor((e.x+e.dir*ENEMY_SPEED*12)/TILE);
      // Only move if platform in front
      let below = charAt(nx, ey+1);
      let front = charAt(nx, ey);
      if((below==='='||below==='|') && (front===' '||front==='*')) {
        e.x += e.vx;
      } else {
        e.dir *= -1;
        e.vx = ENEMY_SPEED*e.dir;
      }
      // --- Attack by player (attack hitbox)
      if(p.attacking && attackTimer>0) {
        let ax = p.facing>0 ? p.x+18 : p.x-2;
        let ay = p.y+8;
        if(Math.abs(ax-e.x-8)<14 && Math.abs(ay-e.y-8)<14) {
          e.dead=true;
        }
      }
      // --- Damage player on contact (if not invulnerable)
      if(!p.invuln && !e.dead && Math.abs(p.x-e.x)<14 && Math.abs(p.y-e.y)<14) {
        p.hp -= ENEMY_DAMAGE;
        p.invuln = 30; // 0.5s
        if(p.hp<=0) {
          p.hp = 0; gameOver = true;
        }
      }
    }
    if(p.invuln) p.invuln--;

    // --- Door/level generation ---
    let door = doorAt(Math.floor((p.x+8)/TILE), Math.floor((p.y+8)/TILE));
    if (door && !dialogActive) {
      // Generate new room every time!
      let newRoom = generateRoom();
      rooms["autogen"] = {
        name: "Procedural Room",
        map: newRoom.map,
        doors: [ { x: newRoom.door.x, y: newRoom.door.y, target: "autogen", tx: 1, ty: newRoom.door.y } ],
        bg: "#181035"
      };
      switchRoom("autogen", 1, newRoom.door.y, p.hp);
      gameState.enemies = JSON.parse(JSON.stringify(newRoom.enemies));
      return requestAnimationFrame(gameLoop);
    }

    // --- NPC/Lore Interact ---
    if ((keys['e']||controlsState.interact) && !dialogActive) {
      let tx = Math.floor((p.x+8)/TILE), ty = Math.floor((p.y+8)/TILE);
      let sym = charAt(tx, ty-1);
      if (sym==='n') {
        showDialog(["We waited for you, 🜲.","The unbelievers are near."], [
          ["Accept the truth", () => { showDialog("A strange energy fills the air..."); gameState.corruption++; }],
          ["Walk away", () => {}]
        ]);
      }
      if (sym==='@') showDialog(["Day 17: Flakious spoke through the void."]);
      controlsState.interact = false;
    }

    if (p.attacking) {
      attackTimer--;
      if (attackTimer<=0) { p.attacking = false; attackTimer = 0; }
    }

    // --- Render ---
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = rooms[gameState.room].bg;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.globalAlpha = 0.14+Math.random()*0.04;
    ctx.fillStyle = "#312045";
    ctx.fillRect(0,0,canvas.width,canvas.height); ctx.globalAlpha = 1;
    let map = rooms[gameState.room].map;
    for (let y=0;y<map.length;y++)
      for (let x=0;x<map[0].length;x++)
        drawTile(map[y][x], x*TILE, y*TILE);
    // Enemies
    for(let e of gameState.enemies) if(!e.dead)
      drawTile('*', e.x, e.y);
    // Player
    if(!p.invuln || (p.invuln%4<2))
      drawPlayer(p.x,p.y,p.facing,p.attacking,attackTimer);
    drawHearts(p.hp);
    ctx.font = "bold 16px "+font; ctx.fillStyle="#b3aaff";
    ctx.textAlign = "center";
    ctx.fillText(rooms[gameState.room].name, CANVAS_BASE_W/2, 32);
    requestAnimationFrame(gameLoop);
  }

  function charAt(tx,ty) {
    let map = rooms[gameState.room].map;
    if (tx<0||ty<0||ty>=map.length||tx>=map[0].length) return ' ';
    return map[ty][tx];
  }
  function collideWithMap(nx, ny) {
    let tx = Math.floor((nx+8)/TILE), ty = Math.floor((ny+16)/TILE);
    let ch = charAt(tx,ty);
    if (ch==='='||ch==='|') return {x: true, y: true};
    return {x: false, y: false};
  }
  function doorAt(tx,ty) {
    let map = rooms[gameState.room].map;
    if (tx<0||ty<0||ty>=map.length||tx>=map[0].length) return null;
    if (map[ty][tx]==='+') return {x:tx,y:ty};
    return null;
  }
  function switchRoom(name, tx, ty, hp) {
    gameState.room = name;
    gameState.player.x = tx*TILE;
    gameState.player.y = ty*TILE;
    gameState.player.hp = hp||MAX_HP;
    gameState.player.vy = 0;
    gameState.player.jumpCount = 0;
    gameState.player.invuln = 0;
    gameState.player.attacking = false;
  }

  // --- Restart on Game Over ---
  window.addEventListener("keydown", function(e){
    if(gameOver && (e.key==="r"||e.key==="R")) {
      let autogenRoom = generateRoom();
      rooms = {
        autogen: {
          name: "Procedural Room",
          map: autogenRoom.map,
          doors: [ { x: autogenRoom.door.x, y: autogenRoom.door.y, target: "autogen", tx: 1, ty: autogenRoom.door.y } ],
          bg: "#181035"
        }
      };
      Object.assign(gameState, {
        room: "autogen",
        player: {x: 32, y: 64, vx: 0, vy: 0, hp: MAX_HP, onGround: false, facing: 1, attacking: false, jumpCount: 0, invuln:0},
        dialog: null,
        enemies: JSON.parse(JSON.stringify(autogenRoom.enemies)),
        notes: [],
        corruption: 0
      });
      gameOver = false;
    }
  });

  showDialog("Welcome to ZETA: Descent into Void");
  requestAnimationFrame(gameLoop);

  </script>
</body>
</html>